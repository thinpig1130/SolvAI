
# 📌 **1. 기존 시스템 기능 분석 (Functional Analysis Only)**

## 1.1 시스템 주요 기능 구성요소

현재 서비스는 크게 다음 네 가지 기능 모듈로 구성되어 있다.

### **(1) 사용자 입력 수집 기능**

* 텍스트 입력 필드 제공
* 질문/요청/상황 설명 등 단일 자연어 입력만 수집
* 추가적인 선택옵션(페르소나, 톤, 목표 등)은 존재하지 않음
* 입력 데이터 구조:

  ```
  {
    "user_id": <UUID>,
    "text": "<사용자 입력>",
    "timestamp": <입력 시각>
  }
  ```

---

### **(2) 대화 요청 생성 기능 (Request Builder)**

사용자 입력을 받아 LLM 호출 형식으로 변환한다.
구성 방식은 **고정 시스템 프롬프트 + 사용자 메시지**의 단일 구조다.

```
messages = [
  { "role": "system", "content": "<고정 프롬프트>" },
  { "role": "user", "content": "<사용자 입력>" }
]
```

특징:

* 시스템 프롬프트는 서비스 전체에서 공통
* 사용자별·대화별·대상별 변형 없음
* 모델 파라미터도 전역 설정(temperature, max_tokens 등 변화 없음)

---

### **(3) LLM 응답 생성 기능**

LLM 엔진(gpt-oss 또는 선택된 모델)에 메시지를 전달하고 응답을 받아오는 기능.

* 입력 형식: messages 배열 그대로 전달
* 응답 형식: 단일 assistant 메시지
* 대화의 톤·어조·역할은 시스템 프롬프트의 기본 설정을 그대로 따름
* 모델 응답 예:

  ```
  {
    "role": "assistant",
    "content": "<생성된 답변>"
  }
  ```

특징:

* 모델은 첫 턴에서 개인화 정보가 없으므로 일반적 응답만 생성
* 대화 초기의 톤은 매 세션마다 동일하게 반복

---

### **(4) 대화 유지 및 기록 기능**

생성된 메시지는 DB 또는 메모리 스토어에 기록된다.

저장 구조 예:

```
conversation_messages = [
  { role: "user", content: "...", turn: 1 },
  { role: "assistant", content: "...", turn: 1 },
  ...
]
```

특징:

* 단순히 메시지 로그만 유지
* 모델 호출 시 이전 메시지를 전부 또는 일부 전달
* 톤·역할·상태(State)는 유지되지 않음

---

## 1.2 기능 흐름 상세 (실제 실행 기준)

아래는 실제 서비스가 수행하는 기능 흐름을 단계별로 분해한 것이다.

### **Step 1. 사용자 입력 수신**

* 사용자의 입력을 단일 텍스트 형태로 받음
* UI 상에서는 “메시지 입력창”만 제공됨

---

### **Step 2. 시스템 프롬프트 적용**

모든 요청은 동일한 시스템 메시지가 앞에 붙는다.

* 특정 역할 부여 없음
* 특정 페르소나 없음
* 특정 화자 스타일 없음
* 특정 사용자 정보 없음

즉, 모든 대화는 같은 “기본 프롬프트”로 시작된다.

---

### **Step 3. 모델 호출**

Request Builder가 구성한 messages 배열을 그대로 LLM에 전달한다.

* API: `/v1/chat/completions`
* 모델: gpt-oss:20b (고정)
* 파라미터: temperature, max_length 등 고정값

모델의 응답은 단일 assistant 메시지이며,
시스템은 이를 직렬화해 프런트엔드로 반환한다.

---

### **Step 4. 대화 기록 관리**

* 수신한 모든 메시지를 DB에 저장
* 이후 호출 시 이전 대화 기록을 그대로 포함하여 전달(맥락 유지)
* 단, 프롬프트 구성 로직은 동일 → 매 턴 시스템 메시지가 고정됨

---

## 1.3 기존 기능 구조의 특성 및 한계

아래는 기능 실행 관점에서 드러난 구조적 사실들이다.

### **① 시스템 프롬프트가 정적(Static)이다**

* “시스템 기본 규칙”이 모든 요청에 동일하게 적용
* 사용자 맥락, 상태, 목적을 반영할 수 없음
* 초반 반응이 늘 같고 개성이 없음

---

### **② 사용자 정보 활용 기능 없음**

DB에 유저 정보가 존재해도:

* 직무/나이대/관심사
* 과거 대화 톤
* 선호 스타일
* 회상 경험 패턴

등은 LLM 호출에 전혀 반영되지 않는다.

기능적 간극:

* **저장 기능은 있으나 활용 기능이 없다**

---

### **③ 톤·역할·페르소나와 관련된 기능이 존재하지 않음**

현재 기능으로는 다음이 불가능하다.

* “아버지처럼 말해줘”
* “친구처럼 반말로 대화해줘”
* “차분한 말투로 말해줘”
* “엄격한 코치 같은 스타일로 설명해줘”

이유:

* 시스템 수준에서 톤/페르소나 변수를 처리하는 기능이 없음
* 프롬프트에 변수를 삽입해 동적으로 구성할 수 없음

---

### **④ 콘텐츠 생성 모드의 전환 기능이 없음**

예를 들어:

* 분석 모드 ↔ 창작 모드
* 조언 모드 ↔ 회상 유도 모드
  전환을 자동으로 지원하는 기능이 없다.

현재 구조는 다음과 같이 단순하다.

```
입력  →  모델  →  답변
```

---

### **⑤ 대화 상태(State) 관리 기능 없음**

시스템은 다음을 기억하지 못한다.

* 현재 역할
* 사용자 성향
* 정서적 상태
* 회상 유도 목적 여부
* 대상에 대한 친밀도

대화의 층위가 모두 동일하고 수평적이다.

---

## 1.4 기능적 문제의 본질

위 기능 분석에 따르면 기존 시스템의 핵심 문제는 다음과 같다.

> **사용자별·목적별·상황별로 다르거나 유지되어야 할 정보를 기능적으로 반영할 구조가 아예 존재하지 않는다.**

즉,

* 시스템프롬프트는 고정적이고
* 변수 기반 동적 프롬프트 기능이 없고
* 사용자 프로필을 활용하는 기능이 없고
* 대화 상태를 관리하는 기능이 없으며
* 역할/페르소나를 반영하는 기능이 없다.

기능적으로 너무 단순하기 때문에
“개인화된 대화”라는 기능은 구현 자체가 불가능한 상태가 된다.

---

원한다면 바로 이어서
**“페르소나 기반 개선 워크플로우 기능 분석”**도 만들어줄게.
