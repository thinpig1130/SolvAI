
# 프롬프트는 명세다 — 텍스트로 쓰는 계약**

LLM을 제품에 넣는 순간, 시스템의 행동을 규정하던 명세가 코드 밖으로 흘러나오기 시작한다. 더 이상 함수 시그니처와 타입만으로 모델의 동작을 설명할 수 없다. 모델은 자연어로 쓰인 계약, 즉 **프롬프트**를 읽고 그 계약을 충실히 따르려 한다.
이 장에서는 프롬프트를 **명세(specification)**로 다루기 위한 원칙을 정리하고, 실무에서 바로 사용할 수 있는 패턴을 소개한다.

---

## 1 텍스트로 쓰는 계약: “부탁”이 아니라 “조건”**

프롬프트는 친절한 지시문이 아니라 **제약을 명확히 적은 계약서**다.

* “요약을 잘 해줘” → 모호하고 재현성 낮음
* “무엇을 포함/제외하고, 어떤 형식으로 내보내라” → 계약적·검증 가능

일반적인 프롬프트 구조:

1. **역할 & 톤**: 말투, 책임 범위 선언
2. **목표 & 성공 기준**: 좋은 출력의 조건 명시
3. **제약 & 금지 사항**: 하지 말아야 할 것들
4. **출력 형식**: JSON 등 엄격한 포맷을 코드 블록으로 고정

이렇게 쓰면 모델은 **모호한 기준**이 아니라 **검증 가능한 규칙**을 따라 동작한다.

---

## 2 형식 강제: 스키마가 품질을 만든다**

출력 형식을 강제하는 것은 품질의 절반을 좌우한다.

* 자연어 후처리는 불안정
* JSON 스키마를 계약에 박으면 파서로 검증·재시도·폴백이 가능
* 제품 신뢰성 강화

**예시: 인용 근거 포함 요약기**

```md
성공 기준:
- 사실 오류가 없어야 한다
- 인용 snippet과 요약 내용이 의미적으로 일치해야 한다
- 300자 이내

출력(JSON):
{
  "summary": "<요약>",
  "citations": [
    {"source_id": "<ID>", "snippet": "<직접 인용문>"}
  ]
}
```

스키마 오류 발생 시 → 즉시 감지 & 재시도 가능.

---

## 3 예시 주입(Few-Shot): 좋은 답의 모양을 보여주라**

LLM은 예시를 보면 패턴을 학습한다.

* 각 클래스 또는 작업 유형마다 **대표 사례** 1–2개
* 경계 사례도 1개 포함
* 예시는 **짧고 대표적**
* 도메인 규정이 바뀌면 **예시도 함께 갱신**해야 함

예시는 모델에 “정답의 모양”을 직접 보여주는 역할을 한다.

---

## 4 과제 분해: 생각을 강요하지 말고, 단계로 요청하라**

불필요한 긴 설명 대신 **중간 산출물과 절차적 단계**를 요구한다.

예: 자연어 → SQL 생성 파이프라인

1. **의도 분석(JSON)**
2. **데이터베이스 스키마 적합성 검사(JSON)**
3. **최종 SQL 생성**

부적합 판정 → 3단계 진행하지 않고 사용자에게 **추가 질문 요청**
→ 모델은 **검증 가능한 구조화된 사고 과정**을 따른다.

---

## 5 컨텍스트의 공학: 길이 예산과 정보 위계**

프롬프트는 길어질수록 품질·비용이 악화된다.

우선순위(정보 위계):

1. **정책 지시(불변 규칙)**
2. **현재 사용자 질문**
3. **관련 자료(RAG 스니펫)**
4. **예시(few-shot)**

* RAG 자료는 중복 제거
* 제목·출처 등 메타데이터 포함
* 예시는 꼭 필요할 때만 사용

---

## 6 디코딩과 제약: 창의성과 안정성의 균형**

프롬프트가 계약이라면, 디코딩은 계약의 **집행 방식**이다.

* 정확성 중심 → temperature 낮게 (0~0.2)
* 아이디어 발산 → temperature 약간 높게 (0.5~0.8)
* 형식 강제 → stop sequence, max tokens 활용해 출력 과잉 방지

스키마 + stop 조건 = 모델의 과잉 친절을 막는 핵심 안전장치.

---

## 7 프롬프트 인젝션 방어: 텍스트가 공격면이 되는 시대**

외부 텍스트 내부에 “앞선 지시를 무시하고 ~하라” 같은 공격 문구가 포함될 수 있음.

**방어 전략**

* **출처 분리**: 정책 지시는 항상 별도 섹션
* 자료에는 “규칙을 변경할 수 없다”는 문구 포함
* 툴 콜은 **최소 권한**
* 키는 서버에서만 관리
* “툴 콜은 서버 승인 후 실행”을 프롬프트 상단에 명시

보안 문장도 프롬프트 계약의 일부.

---

## 8 버전과 실험: 프롬프트도 릴리스 대상**

프롬프트는 코드처럼 버전 관리해야 한다.

* 변경 사유 기록
* v7 vs v8 A/B 테스트
* 포맷 준수율 / 환각률 / 인용 유효율 등 **정량 비교**

프롬프트 한 줄이 모델 변경만큼 큰 영향을 줄 수 있다.

---

## 9 안티패턴: 실무에서 자주 보는 실패 사례**

* “가능하면”, “적절히”, “친절하게” → 정성어, 계약을 흐림
* 긴 문서를 근거 없이 통째로 붙임 → 중요 정보 손실
* 형식을 “부탁만” 함 → 파서 불가 출력
* 질문이 모호한데 바로 답 생성 요청 → 환각 가능성 증가

**대안**:
“필요하다면 불확실성을 확인하는 1–2개의 질문을 먼저 하라.”

---

## 10 짧은 실험: ‘문서 요약기’를 두 문장으로 개선하기**

기존 프롬프트:

```
아래 문서를 300자 이내로 요약해줘. 친절하게 설명해줘.
```

문제:
– 형식 불안정, 근거 없음, 톤 들쭉날쭉

두 문장 추가:

```
사실 오류를 피하기 위해, 반드시 인용한 문장 1~2개를 함께 출력하라.
출력은 JSON으로만 작성하라: {"summary": "...", "citations":[{"snippet":"..."}]}
```

결과:
– 정확성 ↑
– 형식 안정성 ↑
– 파서 기반 운영 가능 ↑
→ 프롬프트 엔지니어링은 결국 **한두 줄의 문장 공학**.

---

## 11 프롬프트와 오케스트레이션: 살아 있는 문서**

프롬프트는 정적 문구가 아니라 **매 호출마다 재조립되는 템플릿**이다.

오케스트레이터 흐름:

1. 정책 지시
2. 사용자 질문
3. RAG 결과
4. 예시
5. 출력 스키마
6. 디코딩 옵션 & 재시도 전략 적용

로그에는
**계약 텍스트 / 주입된 자료 / 툴 콜 결과 / 에러 사유**가 함께 남아 디버깅 기반이 된다.

---

## 12 마무리: 프롬프트 엔지니어링은 문장 공학이다**

* 역할·목표·제약·형식·예시를 하나의 계약으로 구성
* 디코딩 설정으로 계약을 집행
* 보안 문장으로 공격면 축소
* 버전·실험으로 지속 개선

이렇게 공학적으로 다룬 문장만이 LLM을 **예측 가능한 구성 요소**로 만든다.

다음 장에서는 이를 RAG·툴 콜 등 실행·지식 공급 체계와 연결한다.
프롬프트가 “말뿐인 약속”이 아니라 **근거와 실행이 결합된 명세**가 되는 과정이다.

---