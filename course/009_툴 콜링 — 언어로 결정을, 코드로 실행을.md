
---

# **5장. 툴 콜링 — 언어로 결정을, 코드로 실행을**

*언어 모델의 판단(LLM)과 실제 행위(코드)를 안전하게 분리하는 기술*

---

## **5.1 왜 툴 콜링인가**

**LLM = 판단자**, **코드 = 실행자**

* LLM이 직접 DB 수정/결제/외부 API 호출을 하면 재현성과 책임성 붕괴
* 툴 콜링은 모델을 **“제안자”**로 제한
* 서버는 제안된 인자를 **검증**, 실패 시 **수선 프롬프트**로 재생성
* 언어적 추론과 결정적 실행을 분리하여 안정성·감사 가능성 확보

---

## **5.2 툴의 세 가지 형태**

1. **읽기(READ)** — 조회 API, DB select
2. **계산(CALC)** — 환율, 요율, 세금 등 순수 함수
3. **쓰기(WRITE)** — 티켓 생성, 결제 승인, 휴가 신청

    * 쓰기 툴은 보통 **두 단계 승인(제안→확정)** 필요

---

## **5.3 스키마가 계약이다**

툴 콜링의 핵심은 **JSON Schema**

* 필드 타입, 열거형, 패턴, 최소/최대 길이, 기본값까지 포함
* 모델이 만든 인자는 반드시 스키마 검증을 통과해야 함
* 출력도 스키마 검증해 UI 깨짐 방지

```json
{
  "name": "getOrderStatus",
  "description": "주문 상태 조회 (read)",
  "input_schema": {
    "type": "object",
    "properties": {
      "orderId": {"type": "string", "pattern": "^[A-Z0-9]{3,}$"},
      "includeHistory": {"type": "boolean", "default": false}
    },
    "required": ["orderId"]
  }
}
```

---

## **5.4 오케스트레이션 흐름**

1. 사용자 질문
2. 모델이 툴 선택 및 인자 제안
3. 서버가 **검증 후 실행**
4. 모델이 결과를 **사용자 친화적 설명으로 변환**
5. 필요한 경우 다음 행동 제안 (하지만 실행은 사용자 승인 후)

→ **제안 → 검증 → 설명** 의 3단 루프

---

## **5.5 실패 다루기**

* 타임아웃, 재시도(지수 백오프), 서킷 브레이커
* 쓰기 툴에는 **멱등성 키**
* 모델은 오류 사유를 지어내지 않고, 서버의 표준 오류 메시지만 사용

---

## **5.6 보안 원칙**

* **API 키는 절대 모델에 주지 않음**
* 툴은 **최소 권한**
* 쓰기 툴은 **두 단계 승인**
* 프롬프트 최상단에 정책 삽입

    * “모델은 툴을 직접 실행할 수 없고, 제안만 한다.”

---

## **5.7 프롬프트 설계 규칙**

* 언어적 추론 자유
* 행동 규칙은 강하게 제한
* 핵심 정책 예:

    1. 툴은 제안만
    2. 스키마 엄수
    3. write 툴은 이유·근거 JSON 제출 후 승인 대기
    4. 시스템 오류는 포맷만 변환해 사용자에게 전달

---

## **5.8 다중 툴 시나리오**

* 여러 단계가 필요한 요청:
  “다음 주 화요일 면담 잡아줘”
  → 캘린더 조회 → 후보 제안 → 사용자 확인 → 일정 생성
* 먼저 **행동 계획**을 짧게 세우고
* 단계별로 툴을 하나씩 실행

---

## **5.9 사용자와 함께 닫는 루프**

* 쓰기 툴은 항상 **요약·영향·인자 미리보기** 제공
* “이대로 제출” / “수정” UX 필요
* 모델이 독단적으로 실행하는 상황을 차단

---

## **5.10 테스트 전략**

전통적 정답 기반 X
→ **성공률 기반 평가**

**오프라인 평가 지표**

* 툴 선택 정확도
* 인자 스키마 유효율
* 호출 성공률
* 멱등성 준수율
* 재시도 후 복구율

**온라인 지표**

* 승인율
* 취소율
* 수정률
* 오류 유형

---

## **5.11 로그·감사 전략**

* 모든 요소를 하나의 트레이스로 묶기

    * 프롬프트(정책·질문·RAG 문서)
    * 모델의 툴 제안 JSON
    * 서버 검증 결과
    * 실제 툴 I/O
    * 사용자 승인/수정 기록
* PII 마스킹 및 보존 기간 정책 필수

---

## **5.12 RAG + Tool Calling**

* RAG: 규정·문서를 찾아 근거 제공
* 툴: 그 근거를 실제 행동으로 연결
* 근거 조각을 툴 인자 메타데이터로 전달할 수 있음
  → 승인자가 “어떤 조항을 근거로 했는지” 확인 가능

---

## **5.13 긴 작업 처리**

* 비동기 툴 + **job_token**
* 모델은 “생성 중”, “약 n분 소요” 안내
* getJobStatus 또는 푸시 알림 사용
* 긴 작업을 동기 툴로 만들면 UX·비용↑

---

## **5.14 흔한 실패와 교정**

* 실패 1: 없는 툴 이름 생성
* 실패 2: 스키마 불일치
* 해결책:

    * 툴 카탈로그 명시
    * 짧고 확실한 툴 이름
    * enum·정규식으로 자유도 줄이기
    * “툴 목록에 없는 작업은 제안하지 말 것” 명시

---

## **5.15 작동 예: 휴가 신청 보조**

1. 사용자: “다음 주 수·목 쉬고 싶어. 대체 가능해?”
2. 모델 → `getLeaveBalance`, `getPolicy` 제안
3. 서버 → 잔여 1일, 이월 최대 5일, 대체휴무 불가
4. 모델 → 자연어 설명 + `proposeLeaveApplication` 제안
5. 사용자 승인 → 서버가 실제 신청서 생성

→ 언어(판단) + 코드(실행)의 결합

---

# **맺음말**

툴 콜링은 LLM 시대의 **시스템 호출**이다.

* LLM은 **무엇을 할지 판단**
* 코드는 **어떻게 실행할지 결정**
* 스키마(계약) · 승인(보안) · 로그(책임성)를 갖춘다면
  현업 핵심 업무 자동화까지 안전하게 확장할 수 있다.

다음 장에서는 **RAG + 툴 콜링의 평가·모니터링 체계**를 다룬다.

---

필요하시면:

* 슬라이드용 20~30장 버전
* 강의자용 스크립트 포함 버전
* 실습 과제 포함 버전
* 그림/도해 추가 버전
  으로도 만들어 드릴게요!
