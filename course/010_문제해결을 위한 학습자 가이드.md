# 문제해결을 위한 학습자용 가이드

SolvAI Lab: **AI Literacy in Action** 평가를 위한 학습자가 직접 작성할 수 있는 **문제해결 가이드**입니다. 

---

## 1. 기존 서비스 분석

### ✔ 목적

* 현재 서비스 또는 대상 문제의 구조/흐름 이해
* LLM·RAG·툴콜 도입 필요 지점 식별 기반 마련

### ✔ 작성 항목
| 작성항목        | 내용                            |
|-------------|-------------------------------|
| **서비스 개요**  | 무엇을 위한 서비스이며 어떤 기능들이 있는 지 작성  | 
| **현재 기능 흐름** |  사용자 여정(UX Flow) 또는 백엔드 처리 흐름 |
| **문제점/개선 필요 지점** | LLM이 개입해야 하는 이유를 기능 단위로 구분해 정리 | 

### ✔ 예시 구조

* 서비스 분석
* 사용자 시나리오 (AS‑IS)
* 기술 구조 (AS‑IS Architecture)
* LLM·AI 도입 필요 포인트

---

## 2. RAG, Tool calling, LLM 연계 구현 포인트 요소 정의

### ✔ 목적

* 어떤 기능을 LLM/RAG/툴콜로 해결할지 “기능 단위 요소”로 분리
* 각 요소를 왜 이 기술로 구현해야 하는지 근거 제시

### ✔ 작성 항목
| 작성항목        | 내용                            |
|-------------|-------------------------------|
| **요소명** | (예: 사용자 질문 요약, 문서 검색, 외부 API 호출) |
| **선택 기술** |  RAG / Toolcalling / Prompting / Fine‑tuning 여부 |
| **선정 기준 및 이유** | * 정확도 필요성 <br> * 실시간성 여부 <br> * 데이터 최신성 반영 필요 <br> * 외부 시스템 호출 필요 등 |

### ✔ 예시 템플릿

| 기능 요소     | 적용 기술       | 선정 이유(근거)                 |
| --------- | ----------- | ------------------------- |
| FAQ 자동 응답 | RAG         | 사내 문서 최신 내용 필요, 정답 일관성 확보 |
| 결제 진행 요청  | Toolcalling | 결정적 행위(실수 방지), 로그 추적 필요   |
| 사용자 의도 파악 | Prompting   | 흐름 제어 목적, 비용 낮음           |

---

## 3. 프롬프트 및 벡터화, Tool calling 대상 데이터 및 기능 정의

### ✔ 목적

* LLM이 어떤 입력을 받고 어떤 출력 형태를 만들어야 하는지 명확하게 정의
* RAG의 경우 **벡터화 대상 데이터 스키마·메타데이터** 명시 필수

### ✔ 작성 항목
| 작성항목        | 내용                                                                                    |
|-------------|---------------------------------------------------------------------------------------|
| **프롬프트 설계 요소 정의** | * 입력 형태 (사용자 입력 예시) <br> * 기대 출력 형식 (JSON, 문장, 리스트 등) <br> * 필수 포함 정보 <br> * 예외 처리 규칙 | 
 | **벡터화 데이터 정의** | * 문서 종류 (FAQ, 정책, 가이드 문서 등) <br> * Chunking 전략 (길이, 분리 기준)  <br> * 메타데이터(작성일, 카테고리 등) <br> * 기대하는 Retrieval 결과 | 

### ✔ 예시 템플릿

**프롬프트 요구사항**

* 기본 프롬프트
* 사용 변수: {"intent": "", "detail": ""}
* 변수 예시 : 
* 변수 출처

**벡터 데이터 요구사항**

* 문서: A서비스 매뉴얼 120p
* Chunk: 300 tokens, Section 단위 구분
* Metadata: {section, page, updated_at}

---

## 4. 모델 선정 및 워크플로우 모의 실험

### ✔ 목적

* 왜 특정 모델(예: GPT‑4o, GPT‑5-mini, Llama3)로 선택했는지 근거 제시
* 경량 모델과 고성능 모델 비교 가능

### ✔ 작성 항목
| 작성항목        | 내용                                                                                    |
|-------------|---------------------------------------------------------------------------------------|
| **후보 모델 2~3개 리스트**와 비교 기준 |  * 정확도 / 응답 속도 / 비용 / 맥락 길이 / 로컬 가능 여부(Ollama 등) | 
| **선정 모델과 이유** | **워크플로우 시뮬레이션** (모의 데이터 사용) <br> 입력 , 처리 단계 (Prompt → RAG → Toolcall 흐름), 예상 출력, 실제 시연 결과 |

### ✔ 워크플로우 예시

```
User Input → Intent Detection → RAG 검색 → 후보 답안 생성 → Toolcalling 여부 판단 → 최종 응답
```

---

## 5. 시나리오 성공 사례 발굴 및 구현 요소 검토

### ✔ 목적

* 만든 시나리오가 실제로 서비스 관점에서 “유의미한 효과”가 있는지 평가
* 예상 위험 요소 점검

### ✔ 작성 항목

| 작성항목        | 내용                                                                                    |
|-------------|---------------------------------------------------------------------------------------|
| 성공 시나리오 사례 | * 어떤 사용자 행동에서 자동화 혹은 정확도 향상이 발생하는지<br> * 정량적 개선 지표(반응속도, 오류 감소 등) |
| 워크플로우 데이터 흐름 | * 사용자→LLM→RAG→툴콜→DB→응답 흐름을 화살표로 표기 <br> * 가능한 오류 지점 및 보완 방법 포함 |

### ✔ 예시 그림 (텍스트)

```
[User] → [LLM Intent] → [RAG Search] → [답변 생성] → [Toolcall] → [DB] → [최종 응답]
```

### ✔ 리스크 체크리스트

* 개인정보 포함 여부
* 환각 가능성 및 보완책
* 로그/감사 요구사항
* 서비스 SLA/SLO 고려

---

## ✔ 최종 제출 문서 구성 권장 순서

1. 기존 서비스 분석
2. LLM·RAG·Toolcalling 요소 정의
3. 프롬프트/벡터 데이터 요구사항
4. 모델 선정 및 워크플로우 실험
5. 시나리오 성공 사례 및 데이터 흐름

---

